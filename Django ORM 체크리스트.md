#DjangoORM
- Range Query는 Inclusive하게 작성되기에 조건의 시작값과 끝값이 포함됨 주의 !
- 날짜 조회 시, exclusive하게 쿼리하는것이 안전함
- select 구문 조회 시, only()를 사용해서 n+1문제를 방지하는 select_related 나 prefetch_related() 가 정상작동 하도록 하자
- 기본적으로 조회에 자주 사용되는 컬럼은 index를 생성하면 조회속도가 향상됨
	- ORM메소드를 기준으로 filter(), order_by(), values() 에 자주 사용되는 컬럼을 인덱스로 하면 좋긴함
- 정렬된 인덱스를 조회에 활용하면, 재 정렬을 방지할 수 있음
- 꼭 실행 계획을 분석해 데이터 특성을 생각해 인덱스를 설계하기
- 읽기 속도보다 쓰기 속도가 중요하다면 인덱스 추가를 고민하기
- 장고에서는 unique제약을 걸 경우, 자동으로 index가 생성됨
	- 다중 컬럼을 unique 제약을 걸 경우 다중 인덱스가 생성됨
	  따라서 여러 개의 컬럼에 한 번에 unique 제약을 걸 때는 컬럼의 순서를 고려하여 설계하기
- 장고에서는 Meta클래스를 통해, 인덱스를 설계하는게 좋음
- 다중 인덱스 설계시, 동치 조건(=)과 비교 표현식(>, <...)을 쓴다면 동치 조건을 사용하는 컬럼을 인덱스의 선행 컬럼으로 지정
	- 관련 내용은 리마큐 보면서 학습하면 될 듯
- LIKE문으로 조회하는 경우, 장고에서는 __contains()로 조회하는 경우
	- '%Guido%'와 같이 %로 모든 문자를 찾는 쿼리로 조회하게 되기 때문에 인덱스가 무시됩니다.
	- 만약 Guido로 시작하는 이름을 찾고자 한다면, __startswith를 사용하자
- 날짜 컬럼도, 수정을 가해서 사용하게 되는 경우 index를 사용하지 않게 된다
- ![[Pasted image 20231018105810.png]]
	- 따라서 아래 그림처럼 사용하자
	![[Pasted image 20231018105834.png]]

- 인덱스를 통한 탐색시, 인덱스만으로도 필요한 데이터를 다 조회할 수 있게 된다면 추가적으로 원본 테이블을 조회하지 않게 됩니다.
	- 커버링 인덱스
- 